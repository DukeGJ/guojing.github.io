<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot获取前端请求参数]]></title>
    <url>%2Fguojing.github.io%2F2019%2F06%2F13%2FSpringBoot%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SpringBoot获取前端请求参数SpringBoot提供了三个注解用于获取前端请求的参数，分别是@PathVariable，@RequestParam，@RequestBody,下面介绍三个参数的用法以及区别 注解 支持类型 支持的请求类型 支持的Content-Type 请求示例 @PathVariable URL Get all /orders/{id} @RequestParam URL Get all /orders?id=1 @RequestParam Body Post/Put/Delete/Patch form-data,x-www.form-urlencoded /orders?id=1 @RequestBody Body Post/Put/Delete/Patch json {“id”:1,”name”:”aa”} @PathVariable示例例如有一个接口获得User信息：前端请求路由：localhost:8080/getUserInfo/1后端@Controller层代码： 12345@GetMapping(&quot;/getUserInfo/&#123;id&#125;&quot;)public User getUserInfo(@PathVariable int id)&#123; int userId = id; return new User(userId);&#125; User代码: 12345678910111213141516public class User&#123; private String name; private int age; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125;&#125; @RequestParam示例依然是获得User信息前端请求路由：localhost:8080/getUserInfo/?id=1后端@Controller层代码： 12345@GetMapping(&quot;/getUserInfo&quot;)public User getUserInfo(@RequestParam int id)&#123; int userId = id; return new User(userId);&#125; @RequestBody示例前端请求路由：localhost:8080/getUserInfo请求参数:body={&quot;id&quot;:0}后端@Controller层代码 12345@GetMapping(&quot;/getUserInfo&quot;)public User getUserInfo(@RequestBody Body body&#123; int userId = body.getId(); return new User(userId);&#125; Json对象代码: 123456789public class Body&#123; private int id; public int getId()&#123; return id; &#125; public int setId(int id)&#123; this.id = id; &#125; &#125; 前端在传递Json对象时，Java方面必须有对应的类去接收该Json对象，其中类属性可以比Json对象中的多，但是不可以少]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean的生命周期]]></title>
    <url>%2Fguojing.github.io%2F2019%2F06%2F08%2FBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Bean的生命周期Spring Ioc对Bean的生命周期管理如下 通过构造函数或者工厂方法创建Bean 为Bean注入属性与其他Bean的引用 执行初始化方法 Bean可以使用 容器在关闭时执行销毁方法 在xml中配置init-method属性执行初始化方法，配置destroy-method执行销毁方法,例如: 123456789101112131415161718192021222324252627public class User&#123; private int name; private Date birthday; public User()&#123; System.out.println(&quot;执行无参构造函数&quot;); &#125; public void setName(String name)&#123; System.out.println(&quot;设置name属性&quot;); this.name = name; &#125; public String getName()&#123; return name; &#125; public void SetBirthday(Date birthday)&#123; System.out.println(&quot;设置birthday属性&quot;); this.birtyday = birthday; &#125; public Date getBirtyday()&#123; return birthday; &#125; public void init()&#123; System.out.println(&quot;执行初始化方法&quot;); &#125; public void destory()&#123; System.out.println(&quot;执行销毁方法&quot;); &#125;&#125; bean.xml内容如下 12345&lt;bean id=&quot;user&quot; class=&quot;main.demo.User&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;demo&quot;&gt; &lt;property name=&quot;birthday&quot;&gt; &lt;bean class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;&lt;/bean&gt; 测试程序如下： 123456789public class Test&#123; public static void main(String[] args)&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); User user = (User)context.getBean(&quot;user&quot;); System.out.println(user.getName()); //调用close()时Spring容器才执行销毁方法 context.close(); &#125;&#125; 执行结果如下: Bean的后置处理器Bean的后置处理器允许调用初始化方法前后对Bean进行额外处理，Bean的后置处理器对Bean的所有实例逐一统一处理，而非某一个实例，典型应用就是AOP。在使用过程中需要实现BeanPostProcessor接口，该接口有两个方法： 方法 说明 postProcessBeforeInitialization 在调用初始化方法之前调用 postProcessAfterInitialization 在调用初始化方法之后调用 具体实例如下： 12345678910111213public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(beanName + &quot; 执行postProcessBeforeInitialization方法&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(beanName + &quot; 执行postProcessAfterInitialization方法&quot;); return bean; &#125;&#125; bean.xml内容如下： 1234567&lt;bean id=&quot;user&quot; class=&quot;main.entity.User&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;demo&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot;&gt; &lt;bean class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=&quot;main.entity.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt; 执行结果如下： 可以看到后置处理器对xml中的Date和user做了处理,并且是在初始化方法前后分别处理]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bean的种类以及作用域]]></title>
    <url>%2Fguojing.github.io%2F2019%2F06%2F08%2FBean%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Bean 的种类普通BeanPerson类 1234567891011121314151617181920212223242526public class Person&#123; private String name; private int age; public Person()&#123; System.out.println(&quot;默认构造函数&quot;); &#125; public Person(String name)&#123; this.name = name; &#125; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public vois setName(String name)&#123; this.name=name; &#125; public String getName( return name; ) public void setAge(int age)&#123; this.age = age; &#125; public int getAge()&#123; return age; &#125;&#125; bean.xml 1&lt;bean id=&quot;person&quot; class=&quot;com.demo.Person&quot;&gt;&lt;/bean&gt; 直接创建Bean的实例并返回 FactoryBean是一个特殊的Bean，具有工厂生产Bean的能力，只能生成特定的对象，必须实现FactoryBean接口，此接口提供的getObject()用于返回特定的bean。 123456789101112131415161718//必须实现FactoryBean接口public class MyFactoryBean implements FactoryBean &#123; //返回bean的实例 @Override public Object getObject() throws Exception &#123; return new Person; &#125; /*返回getObject()的方法创建的bean的类型，如果不知道类型，则返回null，这样可以在不返回bean的情况下检查bean的类型，使用@autowire时会忽略返回null的bean*/ @Override public Class&lt;?&gt; getObjectType() &#123; return Person.class; &#125; /*如果为true,则表明getObject()方法返回的bean是单例并且放入Spring的单例缓冲池，否则是多例*/ @Override public boolean isSingleton() &#123; return false; &#125;&#125; Bean的作用域 类型 说明 singleton 在Spring Ioc容器中仅存在一个实例，Bean以单例的形式存在，默认值 prototype 每次从容器中返回bean时，都会返回一个新的bean实例 request 每次HTTP请求都会创建一个新的bean，该作用域仅限于WebApplicationContext session 每次HTTP Session共享一个bean，不同session使用不同bean，仅限于WebApplicationContext globalSeesion 一般作用于Portlet应用环境，仅限于WebApplicationContext bean.xml 1234&lt;!--每次调用person都会返回相同的实例--&gt;&lt;bean id=&quot;person&quot; class=&quot;com.demo.Person&quot;&gt;&lt;/bean&gt;&lt;!--每次调用person1都会返回新的实例--&gt;&lt;bean id=&quot;person1&quot; class=&quot;com.demo.Person&quot; scopt=&quot;prototype&quot;&gt;&lt;/bean&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bean实例化方式]]></title>
    <url>%2Fguojing.github.io%2F2019%2F06%2F07%2FBean%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[SpringBean实例化的方式主要介绍三种实例化Bean的方式 构造函数 静态工厂 实例工厂 构造函数最常用的实例化方式，Bean必须提供默认的构造函数 1234567891011121314151617181920212223242526public class Person&#123; private String name; private int age; public Person()&#123; System.out.println(&quot;默认构造函数&quot;); &#125; public Person(String name)&#123; this.name = name; &#125; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public vois setName(String name)&#123; this.name=name; &#125; public String getName( return name; ) public void setAge(int age)&#123; this.age = age; &#125; public int getAge()&#123; return age; &#125;&#125; bean.xml内容 12345678&lt;bean id=&quot;person&quot; class=&quot;com.demo.Person&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;person1&quot; class=&quot;com.demo.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;person2&quot; class=&quot;com.demo.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 静态工厂当采用静态工厂的方式创建Bean时，除了要指定class属性之外，还需要指定factory-method属性，并且工厂方法必须是静态的 123456789public class StaticFactory&#123; //方法必须是静态的 public static Person createPerson()&#123; return new Person(); &#125; public static Person createPerson(String name)&#123; return new Person(name); &#125;&#125; bean.xml内容: 1234&lt;bean id=&quot;person&quot; class=&quot;com.demo.StaticFactory&quot; factory-mathod=&quot;createPerson&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;person1&quot; class=&quot;com.demo.StaticFactory&quot; factory-mathod=&quot;createPerson&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; 实例工厂与静态工厂方式相比，采用实例工厂创建Bean时，class属性必须为空，factory-bean属性必须指定为当前类或者父类中包含工厂方法的名称，而该工厂Bean工厂方法必须通过factory-mathod属性指定。必须先有工厂实例，通过实例对象创建实例提供的所有方法都是非静态的 123456789//实例工厂，所有方法非静态public class Factory&#123; public Person createPerson()&#123; return new Person() &#125; public Person createPerson(String name)&#123; return new Person(name); &#125;&#125; bean.xml内容 12345&lt;bean id=&quot;factory&quot; class=&quot;com.demo.Factory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;person&quot; factory-bean=&quot;factory&quot; factory-mathod=&quot;createPerson&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;person1&quot; factory-bean=&quot;factory&quot; factory-mathod=&quot;createPerson&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[集合总结]]></title>
    <url>%2Fguojing.github.io%2F2019%2F05%2F31%2F%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一 背景 通常，我们的程序需要根据程序运行时才知道要创建多少个对象。但除非程序运行，否则我们是不知道程序创建多少个对象。这就要求我们的程序具备一种在任何时间，任何地点创建任意多个对象的。但是这些对象怎么存储呢？首先想到的就是数组，但是数组有一个缺点，即只能存放统一类型数据，而且长度是固定的，故此诞生了集合的概念 二 什么是集合 Java的集合类存放在java.util包下，是一个用来存放对象的容器注意：只能存放对象，如果存放基本数据类型元素，会自动转换为其包装类型集合存放的是多个对象的引用，对象本身还在堆内存中集合可以存放不同类型，不限数量的对象。 三 集合框架图 可以看到，除了Map，其他的都实现了Iterable接口，这是一个用于遍历集合中的元素的接口，主要的方法有iterator(),方法，用来返回一个迭代器，在JDK1.8又新增了两个默认实现方法，spliterator()和forEach(Consumer&lt;? super T&gt; action)方法，前者会用来返回一个可分割的迭代器，目的是为了并行遍历元素，后者按照Iterable对每个元素执行操作，直到处理完所有的元素或者抛出异常，除非实现类另有规定，否则按照迭代器顺序执行，接下来会对所有的接口和实现类进行详细分析。 四 Iterator 迭代器，用来遍历集合中的元素，主要有以下三个方法： 123456//判断是否有下一个元素，在调用next()方法之前应该先调用该方法boolean hasNext();//返回刚越过的元素，迭代器游标后移E next();//从集合中删除刚越过的元素，在调用该方法之前必须调用过next()方法，否则会抛出异常default void remove() 迭代器与其他遍历方式不同的特点在于：迭代器的游标指向两个元素中间，不可以通过游标直接获得对应的元素，从这个方向可以看出有意把集合与遍历分离 List List特点：有序，允许重复 List有典型的三个实现：分别是ArrayList,LinkedList,Vector,接下来详细介绍这三个实现 ArrayList 底层数据结构是数组，查找快，增加，删除慢，且非线程安全的成员变量： 123456789//接口实现标明该集合可以随机访问，克隆，序列化public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;,RandomAccess,Cloneable,java.io.Serializable&#123; //序列化ID private static final long serialVersionUID = 8683452581122892189L; private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; private int size; 构造函数： public ArrayList(int initialCapacity)，指定初始容量 public ArrayList() 默认构造函数，初始容量为10 public ArrayList(Collection&lt;? extends E&gt; c)，初始容量为集合c的大小 LinkedList 底层数据结构是链表，查找慢，增加，删除快，且非线程安全的 Vector 底层数据结构是数组，查找快，增加，删除慢，且是线程安全的]]></content>
  </entry>
</search>
