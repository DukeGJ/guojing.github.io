---
title: 排序算法总结
date: 2019-07-23 16:47:19
tags:
---
# 特点
排序算法|平均时间复杂度|最好情况时间复杂度|最坏情况时间复杂度|空间复杂度|稳定性
--|--|--|--|--|--|
冒泡排序|o(n^2)|o(n)|o(n^2)|o(1)|稳定
选择排序|o(n^2)|o(n^2)|o(n^2)|o(1)|稳定

## 冒泡排序
冒泡排序是一种简单的排序算法，重复的遍历所有元素，一次比较2个元素大小，如果顺序错误交换两个元素，直到没有顺序错误为止
### 算法描述
- 比较相邻元素，如果第一个比第二个大，则交换他们
- 从第0个元素开始，对每一对元素执行同样操作，一次循环可以把最大的元素放在末尾
- 重复上述所有操作直到所有的元素都有序
### 代码实现
```
public void bubbleSort(int[] array){
    if(array == null)
        return;
    //循环次数，直到所有的元素都被比较过
    for(int i=0; i<array.length;i++){
        //一次循环之后，最大的数据被交换到数组末尾
        for(int j=0; j< array.length - i - 1;j++){
            //如果第一个元素比第二个元素大，则交换他们
            if(array[j] > array[j+1]){
                int temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
            }
        }
    }
}
```
#### 优化一
>假设现在排序array[]={1,2,3,4,5,6,7,8,10,9}，经过一次排序之后，按照上述算法，第一趟排序交换10和9之后，序列已经有序，接下来的8趟比较什么都没做，比较多余。所以在交换的时候增加一个标记，如果本趟排序没有交换，说明数组基本有序，不用继续排序;

代码如下：
```
public void bubbleSort1(int[] array){
    if(array == null)
        return;
    //交换标识
    boolean exchange=false;
    //循环次数，直到所有的元素都被比较过
    for(int i=0; i<array.length;i++){
        //一次循环之后，最大的数据被交换到数组末尾
        for(int j=0; j< array.length - 1 - i;j++){
            //如果第一个元素比第二个元素大，则交换他们
            if(array[j] > array[j+1]){
                int temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
                exchange = true;
            }
        }
        //本趟排序没有发生交换，说明数组有序，不需要继续比较
        if(!exchange){
            break;
        }
    }
}
```
#### 优化二
>优化一仅仅适用连片有序而整体无序的情况数据（例如：1,2,3,4,7,6,5）。但是对于前面大部分有序而后半部分无序的数据（例如：1,2,7,4,3,6,9,8,10）排序效率也不可观，对于这种情况，我们依然可以优化，我们可以记录最后一次交换的位置，后边没有交换，那必然是有序的，然后下一次排序从第一个记录比较到上次的记录位置即可。

代码如下:
```
public void bubbleSort2(int[] array){
    if(array == null)
        return;
    //交换标识
    boolean exchange=false;
    //记录上一次交换的结束位置
    int lastPos=0;
    int k = array.length-1;
    //循环次数，直到所有的元素都被比较过
    for(int i=0; i<array.length;i++){
        //一次循环之后，最大的数据被交换到数组末尾
        for(int j=0; j< k;j++){
            //如果第一个元素比第二个元素大，则交换他们
            if(array[j] > array[j+1]){
                int temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
                lastPos=j;
                exchange = true;
            }
        }
        //本趟排序没有发生交换，说明数组有序，不需要继续比较
        if(!exchange){
            break;
        }
        k=lastPos;
    }
}
```
#### 优化三
>优化二已经大大提高效率，还有一种提交效率的方式，鸡尾酒排序（Cocktail Sort）（又名：双向冒泡排序 (Bidirectional Bubble Sort)、波浪排序 (Ripple Sort)、摇曳排序 (Shuffle Sort)、飞梭排序 (Shuttle Sort) 和欢乐时光排序 (Happy Hour Sort)），该排序以双向进行排序，排序时进行一次正向排序，再进行一次反向排序。

代码如下：
```
public void bubbleSort3(int[] array){
    if (array==null)
        return;
    //交换标识
    boolean exchange = false;
    //记录上一次交换的结束位置
    int lastPos = 0;
    //记录上一次交换的起始位置
    int prevPos = 0;
    int k = array.length-1;
    //循环次数，直到所有的元素都被比较过
    for (int i=0;i<array.length;i++){
        //正向排序
        for (int j=prevPos;j<k;j++) {
            if (array[j] > array[j + 1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                exchange = true;
                lastPos = j;
            }
        }
        //本趟排序没有发生交换，说明数组有序，不需要继续比较
        if (!exchange)
            break;
        k=lastPos;
        //反向排序
        for (int j=k;j>1;j--) {
            if (array[j-1] > array[j]) {
                int temp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = temp;
                exchange = true;
                prevPos = j;
            }
        }
        //本趟排序没有发生交换，说明数组有序，不需要继续比较
        if (!exchange)
            break;
    }
}
```
## 选择排序
选择排序是最稳定的排序算法之一,因为无论什么样的数据，复杂度都是o(n^2)，在使用的时候应该是数据规模越小越好，
