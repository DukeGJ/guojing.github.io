---
title: 字符编码引发的惨案
date: 2019-07-02 14:34:43
tags:
---
在收到`byte`数组时,需要转换为`String`字符串,我们都知道,`String`类提供了构造函数可以直接转换,但是调试模式下转换的结果与发布出来的jar包转换的结果不同,排查问题浪费了不少时间，我们先来看一下构造函数够干了些什么，以下是`String`的部分代码：
```
public String(byte bytes[]) {
        this(bytes, 0, bytes.length);
}
public String(byte bytes[], int offset, int length) {
    checkBounds(bytes, offset, length);
    this.value = StringCoding.decode(bytes, offset, length);
}
static char[] decode(byte[] ba, int off, int len) {
    String csn = Charset.defaultCharset().name();
    try {
        return decode(csn, ba, off, len);
    } catch (UnsupportedEncodingException x) {
        warnUnsupportedCharset(csn);
    }
    try {
        return decode("ISO-8859-1", ba, off, len);
    } catch (UnsupportedEncodingException x) {
        MessageUtils.err("ISO-8859-1 charset not available: "+ x.toString());
        System.exit(1);
        return null;
    }
}

```
我们可以看到关键的方法在于`Charset.defaultCharset().name()`方法，通过该方法找到编码格式，来看一下该方法的实现：
```
public static Charset defaultCharset() {
    if (defaultCharset == null) {
        synchronized (Charset.class) {
            String csn = AccessController.doPrivileged(
                new GetPropertyAction("file.encoding"));
            Charset cs = lookup(csn);
            if (cs != null)
                defaultCharset = cs;
            else
                defaultCharset = forName("UTF-8");
        }
    }
    return defaultCharset;
}
```
可以看到默认的编码格式是通过文件的编码格式确定的，由于我的工作空间配置的是UTF-8，所以在调试模式下没有问题，但是到了生产环境出现问题。所以今后在做关于字符的操作时一定要指定编码格式