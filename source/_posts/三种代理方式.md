---
title: 三种代理方式
date: 2019-10-12 14:09:54
tags:
---
# 代理模式
代理模式(Proxy)是一种设计模式，提供了访问对象的另一种方式，即通过代理对象访问目标对象，这样做的好处是可以在目标对象的基础上，进行额外的功能操作，扩展目标对象的功能
# 静态代理
静态代理要求代理对象与目标对象一起实现相同的接口或者继承相同的父类，使用时通过代理对象调用目标对象的相同方法达到代理的目的，举个例子:
首先定义一个接口:
```
public interface UserDao{
    boolean addUser();
}
```
定义目标对象，实现`UserDao`接口:
```
public class UserDaoImpl implements UserDao{
    @Override
    public boolean addUser(){
        System.out.println("add user");
        return true;
    }
}
```
定义代理对象，与目标对象实现相同的接口:
```
public class UserDaoProxy Implements UserDao{
    /**
    * 目标对象
    */
    private UserDao target;
    public UserDaoProxy(UserDao target){
        this.target = target;
    }
    @Override
    public boolean addUser(){
        System.out.println("static proxy");
        return this.target.addUser();
    }
}
```
使用方法:
```
public class StaticProxyTest{
    public static void main(String[] args){
        //创建目标对象
        UserDao target = new UserDaoImpl();
        //创建代理对象
        UserDao userDao = new UserDaoProxy(target);
        userDao.addUser();
    }
}
```
运行结果:
![](静态代理执行结果.PNG)
- 优点是可以在不修改目标对象的情况下对目标功能扩展
- 缺点是代理对象与目标对象必须徐实现一样的接口，会额外增加很多代理类，在修改接口时，需要同时维护目标对象与代理对象
# 动态代理
动态代理使用JDK的API，动态的在内存中构建代理对象，需要目标对象实现接口
使用方法：
```
public class DynamicProxyTest{
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao userDao = (UserDao) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),(proxy,method,argument)->{
            System.out.println("dynamic proxy");
            Object result = method.invoke(target,argument);
            return result;
        });
        userDao.addUser();
    }
}
```
运行结果如下：
![](动态代理执行结果.PNG)
- 不需要创建代理类，但是目标类必须实现接口
# Cglib代理
静态代理和动态代理都要求目标对象必须实现接口，但是有时候目标类只是单纯的类，没有实现任何接口，对于此种情况，我们可以使用Cglib代理，也叫字节增强码代理，子类代理。Cglib包是一个强大高性能的代码生成包，他可以在运行期扩展java类与实现java接口，Cglib底层使用ASM(一个短小而精悍的字节码操作框架)来操作字节码生成新的类，不鼓励直接使用ASM，因为它要求必须对JVM内部结构包括class文件的字节码非常熟悉.
举个例子:
```
public class CglibProxyTest{
    public static void main(String[] args){
        UserDao target = new UserDaoImpl();
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println("Cglib proxy");
                Object obj = method.invoke(target,objects);
                return obj;
            }
        });
        UserDao userDao = (UserDao) enhancer.create();
        userDao.addUser();
    }
}
```
执行结果如下:
![](Cglib代理执行结果.PNG)
- 优点时Cglib不要求目标对象必须实现接口
- 缺点是Cglib的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常，对于final类型的class和method不能代理


