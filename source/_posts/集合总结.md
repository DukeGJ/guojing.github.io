---
title: 集合总结
date: 2019-05-31 01:09:55
tags: Collections
---
# 背景   
  通常，我们的程序需要根据程序运行时才知道要创建多少个对象。但除非程序运行，否则我们是不知道程序创建多少个对象。这就要求我们的程序具备一种在任何时间，任何地点创建任意多个对象的。但是这些对象怎么存储呢？首先想到的就是数组，但是数组有一个缺点，即只能存放统一类型数据，而且长度是固定的，故此诞生了集合的概念
## 什么是集合    
  Java的集合类存放在`java.util`包下，是一个用来存放对象的容器注意：只能存放对象，如果存放基本数据类型元素，会自动转换为其包装类型集合存放的是多个对象的引用，对象本身还在堆内存中集合可以存放不同类型，不限数量的对象。
## 集合框架图
![logo](集合框架图.png)
    可以看到，除了`Map`，其他的都实现了`Iterable`接口，这是一个用于遍历集合中的元素的接口，主要的方法有`iterator()`,方法，用来返回一个迭代器，在JDK1.8又新增了两个默认实现方法，`spliterator()`和`forEach(Consumer<? super T> action)`方法，前者会用来返回一个可分割的迭代器，目的是为了并行遍历元素，后者按照`Iterable`对每个元素执行操作，直到处理完所有的元素或者抛出异常，除非实现类另有规定，否则按照迭代器顺序执行，接下来会对所有的接口和实现类进行详细分析。
# Iterator
  迭代器，用来遍历集合中的元素，主要有以下三个方法：
```
//判断是否有下一个元素，在调用next()方法之前应该先调用该方法
boolean hasNext();
//返回刚越过的元素，迭代器游标后移
E next();
//从集合中删除刚越过的元素，在调用该方法之前必须调用过next()方法，否则会抛出异常
default void remove()
```
迭代器与其他遍历方式不同的特点在于：迭代器的游标指向两个元素中间，不可以通过游标直接获得对应的元素，从这个方向可以看出有意把集合与遍历分离

# List
>List特点：有序，允许重复

List有典型的三个实现：分别是ArrayList,LinkedList,Vector,接下来详细介绍这三个实现
## ArrayList
>底层数据结构是数组，查找快，增加，删除慢，且非线程安全的
成员变量：
```
//接口实现标明该集合可以随机访问，克隆，序列化
public class ArrayList<E> extends AbstractList<E> implements  List<E>,RandomAccess,Cloneable,java.io.Serializable
```
### 构造函数：

```
public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
```
指定初始容量大于0,则新建一个`initialCapacity`大小的数组;如果初始容量为0,则默认使用空集;如果初始容量小于0,则抛出非法参数异常
```
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```
`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`是空集
```
public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
```
如果集合`c`中的元素为空,则使用数组为空集;如果不为空,则当前集合的大小和容量为`c`的大小
### 添加元素
在添加元素时先确保有足够的空间容纳新的元素,具体的操做时，通过当前元素个数与底层存储数组大小比较，如果
## LinkedList
>底层数据结构是链表，查找慢，增加，删除快，且非线程安全的
```
//接口实现表明链式链表支持克隆，序列化，有序
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
```
## Vector
>底层数据结构是数组，查找快，增加，删除慢，且是线程安全的
