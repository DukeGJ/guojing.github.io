---
title: 集合总结
date: 2019-05-31 01:09:55
tags: Collections
---
# 背景   
  通常，我们的程序需要根据程序运行时才知道要创建多少个对象。但除非程序运行，否则我们是不知道程序创建多少个对象。这就要求我们的程序具备一种在任何时间，任何地点创建任意多个对象的。但是这些对象怎么存储呢？首先想到的就是数组，但是数组有一个缺点，即只能存放统一类型数据，而且长度是固定的，故此诞生了集合的概念
## 什么是集合    
  Java的集合类存放在`java.util`包下，是一个用来存放对象的容器注意：只能存放对象，如果存放基本数据类型元素，会自动转换为其包装类型集合存放的是多个对象的引用，对象本身还在堆内存中集合可以存放不同类型，不限数量的对象。
# 集合框架图
![logo](集合框架图.png)
    可以看到，除了`Map`，其他的都实现了`Iterable`接口，这是一个用于遍历集合中的元素的接口，主要的方法有`iterator()`,方法，用来返回一个迭代器，在JDK1.8又新增了两个默认实现方法，`spliterator()`和`forEach(Consumer<? super T> action)`方法，前者会用来返回一个可分割的迭代器，目的是为了并行遍历元素，后者按照`Iterable`对每个元素执行操作，直到处理完所有的元素或者抛出异常，除非实现类另有规定，否则按照迭代器顺序执行。
    `List`,`Map`,`Set`是集合的三大主要接口：
## List
* 有序且允许重复
* ArrayList的底层采用数组实现，查找效率高，增加或者删除效率低，非线程安全的
* LinkedList的底层采用链表实现，每一个`Node`除了保存元素之外，还会保存前驱节点和后继节点，查找效率低，增加或者删除效率高，非线程安全的
* Vector的底层采用数组实现，在一些方法上使用`synchronized`关键字加锁，查找效率高，增加或者删除效率低，线程安全
* CopyOnWriteArrayList底层采用数组实现，在添加对象时会加锁，读取对象时不加锁

## Map
* Map保存的是键值对，其中key不允许重复，允许为null，value可以重复
* HashMap的底层数组实现，hash码相同的key采用链式存储，每一个`Node`都会保存后继节点
* LinkedHashMap的底层采用链表实现，每一个`Entry`除了保存key和value之外，还保存前驱节点和后继节点
* TreeMap底层采用树形结构实现，每一个`Entry`都会保存左子节点，右子节点，父节点
* HashTable的实现基本与HashMap相同，key不允许为null，且部分方法使用`synchronized`修饰，保证数据的一致性
* ConcurrentHashMap底层采用数组实现，key，value都不允许为null
  
## Set
* 无序不允许重复
* HashSet底层采用HashMap存储，利用Map的key不允许重复的特性，允许为null
* LinkedHashSet
* TreeSet底层采用二叉树排序